

# 医链  -- 面向隐私保护的医疗大数据可信流转解决方案

##  一、产品说明

医链，构建更美好的“链”上医疗平台，使数据由储于一个个医疗机构中的孤岛转变为以人为中心的全时空维度视图。平台基于代理重加密提出私密性更强的健康记录共享方案，并打破现有溯源合约显式存储所有权的传统，提出一套基于零知证明的药企供应链产品信息追溯服务方案。安全性更高，隐私性更完备，一站式解决就诊、异地复诊、取药、授权、溯源等问题，助力医疗行业实现健康和就诊数据的可信共享，加速医药数字化生态落地，促进全民建成互联互通的人口健康信息平台，为医疗大数据价值挖掘做技术背书。

## 二、技术创新点

### （1）基于代理重加密(Proxy Re-Encryption)的电子健康记录的共享方案

提及个人健康记录，安全和隐私是患者最为关心的，同时个人应当拥有是否透露细节的权利。如果不能解决链上电子病历流转过程中的隐私泄露和滥用问题，那么就无法保障上“链”患者的数据安全。于是我们提出了基于代理重加密的共享方案，保本方案在便于数据共享的同时也确保了在区块链这个零信任环境下的保密性，同时将用户加密、存储、传输的开销转移到节点上。作为加密数据存储和共享必不可少的加密工具，代理重加密已被广泛用于保护存储在第三方的数据的机密性。

以典型的Alice-Bob模型为例，*Alice*使用公钥加密了一些文件（准确说法应为使用公钥加密对称密钥，再使用对称密钥加密文件，但此处不做区分地使用，以便于叙述），并存储在链上(proxy)，当*Bob*想要获取这些*Alice*的文件时，他向*Alice*提出申请，*Alice*无需从链上下载文件并发送给*Bob*，而是通过调用链上合约将文件重加密为*Bob*的私钥能够解密的数据。

本方案优点在于：

1. 保证Alice向Bob共享某份健康记录时，其他人无法通过合约调用记录查询到Alice的记录共享者。
2. 防止重加密涉及的密钥和需要重加密的明文在链上泄露
3. 拥有传递性和抗合谋等特性，确保对于此零信任环境下的最小信任和最大密钥隐私

### （2）基于零知证明(zk-STARK)的药企供应链产品信息追溯服务方案

现有溯源方案存在的问题有：

* 所有人都可以dump整个区块链，获取所有物品的供应链中的各个环节，而实际上这些信息只应被供应链的参与者与最终的消费者获取；
* 合约以地址->资产或资产->地址的方式存储物品所有权，同理，所有人都可以获取各个用户所拥有的物品或各个物品的所有者。

我们提出基于零知证明的药企供应链产品信息追溯服务方案：



## 三、功能特色



1. 平台将用户的病历、体检数据、可穿戴设备数据汇总起来成为用户的电子健康记录，用户可将数据共享给任意第三方，并且数据是经过验证签名的，并保存在区块链上，保证不可篡改性。比如：去其他医院看病时，将历史病历拿给医生看；去公司入职时，提交历史体检记录；线上看病后，可以凭线上看病的记录直接去加入联盟链中的任意药房取药时



### （1）解决分散就诊记录的数据孤岛问题，健康记录一链直达

不同医疗机构的数据互相独立，患者的健康记录是处于支离破碎的状态，想要获取不同机构或不同时间段的记录非常不便利，没有一个患者维度的全局视图。

使数据由储于一个个医疗机构中的孤岛转变为以人为中心的全时空维度视图。

### （2）解决不同医院间就诊的数据信任问题，跨院就诊

不同医疗机构的诊疗记录和检查检验数据无法保证不可篡改、不可伪造和可溯源，难获得跨机构医疗工作者的信任，导致患者在跨医疗机构就诊时不得不重复进行检查检验，即浪费医疗资源，又给患者带来额外负担。



### （3）解决医疗数据授权共享的数据安全问题，给予医疗大数据技术背书



### （4）解决医药器材质量管理的数据溯源问题，加速构建医药数字化生态









现在的溯源以交易的形式进行

## 四、技术开发方案

### （1）技术栈

* 前端
  * React
  * Ant Design
  * Tailwind CSS
  * Vite
  * WebAssembly
* 后端
  * Node.js
  * TypeScript
  * Fastify
  * 经过裁剪的最小化Contract SDK
* 区块链网络
  * 平台
    * FISCO-BCOS
  * 预编译合约
    * C++
    * Rust FFI
    * [mcl](https://github.com/herumi/mcl)
    * [winterfell](https://github.com/novifinancial/winterfell)
  * 合约
    * Solidity
    * [Liquid](https://github.com/WeBankBlockchain/liquid) (Rust)（微众银行区块链相关开源技术方案）
  * 存储
    * IPFS

### （2）流程

#### 1. 初始化

各个角色申请加入联盟链。此时，各个角色均持有公私钥对，而CA（假设是某个具有公信力的组织）持有身份到公钥的mapping。

####2. 病历流转

病历在上链后只能Create/Read，不能Update/Delete。

##### (a) 患者Alice授权医生Bob Create病历

1. Alice生成 *新的* PRE公私钥对，将公钥发送给Bob
2. Bob以自己的私钥（并非PRE私钥）对病历进行签名
3. Bob生成对称密钥，并使用对称密钥加密病历与签名
4. Bob将加密后的病历上传至IPFS，获得CID
5. Bob使用Alice的PRE公钥加密对称密钥
6. Bob向Alice发送CID与加密后的对称密钥
7. Alice保存CID与对应的PRE私钥
8. Alice以CID生成链上id，并以链上id、加密后的对称密钥调用合约
9. 合约判断链上id是否存在
   * 若存在，则throw
   * 否则保存链上id与加密后的对称密钥

##### (b) 患者Alice Read病历

1. Alice根据保存的CID，生成链上id
2. Alice以链上id调用合约，获取对应的加密后的对称密钥
3. Alice以CID从IPFS获得加密后的病历
4. Alice以PRE私钥解密对称密钥，以对称密钥解密病历
5. 必要时，Alice可以从CA获取Bob对应的公钥，验证真实性

##### (c) 患者Alice授权医生Carol、药房Charlie或科研机构Carlos Read病历

下述过程中，合约无法追踪患者授权了什么数据给谁，进而保护了患者的隐私（匿名性）。

1. Carol/Charlie/Carlos生成PRE公私钥对，将公钥发送给Alice
2. Alice使用待授权的CID对应的PRE私钥与Carol/Charlie/Carlos的PRE公钥生成重加密密钥
3. Alice根据CID，生成链上id，并以链上id、重加密密钥调用合约
4. 合约使用重加密密钥重加密链上id对应的加密后的对称密钥，返回重加密后的对称密钥
5. Alice将CID与重加密后的对称密钥发送给Carol/Charlie/Carlos
6. Carol/Charlie/Carlos以CID从IPFS获得加密后的病历
7. Carol/Charlie/Carlos以PRE私钥解密对称密钥，以对称密钥解密病历
8. 必要时，Carol/Charlie/Carlos可以从CA获取Bob对应的公钥，验证真实性

#### 3. 药品溯源

药品的供应链：生产（生产厂商） -> 运输（货运公司） -> 销售（药房） -> （患者）

##### (a) 数据结构

在存储时，每个药品都是一个键值对，其中键为药品的id，值为trace。

* `id = Hash(key)`，其中key是溯源码，打印在药品包装上。只有能够物理接触药品的参与者才能获取key；
* trace是一个只能push的数组，其中包括以key加密后的各个环节的信息。

值得注意的是，合约并不直接存储药品与其当前所有者的所有权关系，而是通过key证明（物理）所有权、通过trace记录之前的所有者（即供应链的参与者）。

##### (b) 某个环节的参与者David增加trace

1. David填写相关信息data，如：
   * 生产厂商应该填写药品名、生产日期、生产厂商名等；
   * 货运公司应该填写始发地、目的地、运输时间、货运公司名等；
   * etc.
2. David以自己的私钥为数据签名，以供后续环节验证：`sig = Sign(sk, Hash(data))`
3. David加密：`c = Enc(key, { data, sig })`
4. David生成证明，以在不泄露key的前提下证明自己拥有key：`proof = Prove(id = Hash(key))` 
   * 如果必要，可以加入当前区块高度/hash作为nonce，以防止重放
5. David以id、c、proof调用合约
6. 合约验证proof：`isValid = Verify(proof, id)`
   * 若isValid为true，则`drugs[id].push(c)`
   * 否则throw

##### (c) 后续环节的参与者Erin（包括患者Alice）或政府部门Grace 查询/抽检 供应链

1. Erin/Grace以溯源码key计算`id = Hash(key)`，并以此调用合约，获取`drugs[id]`
2. Erin/Grace解密：`drugs[id].map(c => { data, sig } = Dec(key, c))`
3. 必要时，Erin/Grace可以从CA获取David对应的公钥，验证真实性

### （3）核心算法

#### 1. 代理重加密

代理重加密（*Proxy Re-Encryption*，PRE）是一种密文重加密方案。它将*Alice*的数据存储、计算、传输的开销转移到了*Proxy*，在云服务普及的当下具有广泛的应用场景。

##### AFGH方案

早期的代理重加密方案存在诸多问题，如依赖可信第三方、重加密密钥的生成依赖通信双方的私钥等。2006年，Ateniese等人提出了可行且较为完备的方案（下称AFGH方案），该方案以双线性映射作为理论基础，解决了上述的问题。本作品实现了原文中3.2节介绍的方案，其整体流程如下图所示。

<img src="https://i.loli.net/2021/09/18/9BTXhewmPtUrZFD.png" alt="image.png" style="zoom:50%;" />

其中：

* 密钥生成(KeyGen)：
  * 选取乘法群$G_1=<g>,G_2=<h>$，计算$Z=e(g,h)$；
  * Alice：随机选择$SK_a=a∈Z_q^*$，$PK_a=g^{SK_a}=g^a$；
  * Bob：随机选择$SK_b=b∈Z_q^*$，$PK_b=h^{SK_b}=h^b$。
* 加密(Encrypt)：
  * 将明文映射为$M∈G_T$；
  * 随机选择$r∈Z_q^*$，计算密文$C_a=(Z^r M,{PK_a}^r)=(Z^r M,g^{ar})$。
* 解密(Decrypt)：
  * 由$C_a$中的$g^{ar}$计算${e(g^{ar},h)}^{1/SK_a}={e(g^{ar},h)}^{1/a}={e(g,h)}^{ar/a}=Z^r$；
  * 由$C_a$中的$Z^r M$解密${Z^r M}/Z^r =M$。
* 重加密密钥生成(ReKeyGen)：
  * 计算$RK_{a→b}={PK_b}^{1/SK_a}=h^{b/a}$。
* 重加密(ReEncrypt)：
  * 由$C_a$中的$g^ar$计算$e(g^{ar},RK_{a→b})=e(g^{ar},h^{b/a})={e(g,h)}^{arb/a}=Z^{rb}$；
  * 由$C_a$中的$Z^r M$生成重加密密文$C_b=(Z^r M,Z^{rb})$。
* 重解密(ReDecrypt)：
  * 由$C_b$中的$Z^{rb}$计算$(Z^{rb})^{1/SK_b}=Z^{rb/b}=Z^r$；
  * 由$C_b$中的$Z^r M$解密$(Z^r M)/Z^r =M$。

该方案具有如下的优点：

* *Alice*计算重加密密钥$RK_{a→b}$无需*Bob*的私钥；
* *Proxy*无法获取任何关于私钥、明文的信息，因此无需可信第三方；
* 重加密具有单向性，即*Proxy*无法通过$RK_{a→b}$计算出$RK_{b→a}$；
* 防止*Proxy*与*Alice*或*Bob*中的任意一人共谋，解密出对方私钥（$RK_{a→b}=h^{b/a}$，已知$a$求解$b$与已知$b$求解$a$均为离散对数问题）；
* 具备语义安全性。

#### 2. 零知识证明

零知识证明是现代密码学中的重要概念，最早由Goldwasse，Micali和Rackoff于1985年提出，它具有如下性质：

* **完备性**：如果证明者的宣称为真，则他最终将说服诚实的验证者；
* **可靠性**：只有证明者的宣称为真时，诚实的验证者才会被说服；
* **零知识性**：验证者无法从上述过程中获取除了“证明者的宣称为真”这一事实之外的任何信息。
  正是因为其独特性质，零知识证明被广泛地应用于需要隐私保护的场景中。

##### zk-STARK

zk-STARK全称为*Zero-Knowledge Scalable Transparent Arguments of Knowledge*，即*可扩展的透明的零知识证明*。其中，**可扩展**是指随输入语句的扩展，证明的时间线性增加，而验证的时间对数增加；**透明**是指无需可信初始化。该方案分为**算术化**（Arithmetization）与**低度测试**（Low Degree Testing）两个步骤，其交互式版本如下图所示，使用*Fiat-Shamir变换*即可将其转换为非交互式版本。

<img src="https://i.loli.net/2021/09/18/fdklzKAFGrUZbIq.png" alt="image.png" style="zoom:45%;" />

其中：

* Arithmetization：
  * *Prover*、*Verifier*：输入计算语句，并生成多项式约束；
  * *Prover*：执行计算语句，记录执行轨迹，并生成轨迹多项式；
  * *Prover*：将轨迹多项式发送给*Verifier*；
  * *Verifier*：生成随机数$α$并将其发送给*Prover*；
  * *Prover*、*Verifier*：由$α$、多项式约束与轨迹多项式生成组合多项式，双方比较组合多项式是否一致。
* Low Degree Testing：
  * *Verifier*：生成随机数$β_i$并将其发送给*Prover*；
  * *Prover*：使用*FRI*（*Fast Reed-Solomon Interactive Oracle Proofs of Proximity*）算法证明组合多项式与轨迹多项式的次数为某个固定值，并将证明$π_i$发送给*Verifier*；
  * *Verifier*：验证$π_i$，并重复Low Degree Testing过程。

除了**无需可信初始化**外，zk-STARK不使用椭圆曲线与配对密码学，而是使用哈希函数与信息论作为安全性保证，实现了**后量子安全**。

同时，为了证明用户确实拥有某些知识，本作品使用了Rescue Hash。Rescue Hash是专门为zk-STARK优化的抗碰撞密码学哈希函数，在保证安全性的同时极大程度上提高了在数字电路上的性能。

## 五、商业应用场景及价值

国务院于2015年发布《全国医疗卫生服务体系规划纲要》指出：到2020年，实现全员人口信息、电子健康档案和电子病历三大数据库基本覆盖全国人口并信息动态更新。充分利用信息化手段，促进优质医疗资源纵向流动，建立医院与基层医疗卫生机构之间共享诊疗信息、开展远程医疗服务和教学培训的信息渠道。实现公共卫生、计划生育、医疗服务、医疗保障、药品供应、综合管理等六大业务应用系统的互联互通和业务协同。

每一次产业技术的兴起都会伴随着新基础设施的建设，进而带来传统利益格局、产业体系、制度文化的重构。当前中国传统的人口数量红利日渐减少，而围绕新型基础设施建设作创新探索将有望促成新一轮发展红利。云计算、物联网、大数据、区块链等信息化技术的快速发展，为优化医疗卫生业务流程、提高服务效率提供了条件，必将推动医疗卫生服务模式和管理模式的深刻转变。

个人健康记录作为促进智慧城市的医疗建设和大数据应用发展的重要一环，数字化医疗平台的目的是为了让患者可以更好地管理和维护个人健康记录，同时可以进一步提高医疗照护服务和降低成本，未来必将成为了大众体检、看病中不可或缺的一环。

## 六、团队分工 

| 学校             | 姓名   | 角色                 |
| ---------------- | ------ | -------------------- |
| 香港科技大学硕士 | 王为红 | 产品经理、前端工程师 |
| 香港大学博士     | 张诚儒 | 全栈工程师           |
| 华中科技大学学士 | 陈洁   | 视觉设计师           |
| 华中科技大学学士 | 鄢宁   | 交互设计师           |

